{"pages":[],"posts":[{"title":"1654번 - 랜선 자르기","text":"(문제 출처) 난이도 : 실버 3(solved.ac 기준) 언어 : java 문제 요약 N개의 랜선을 일정 길이 만큼 잘라서 K개 이상이 나오는 최대 길이를 구하라.(단, 이미 자른 랜선은 붙일 수 없다.) 유의 사항입력 조건 중 랜선의 길이가 int형의 최대 범위인 231-1까지다.2개 이상의 랜선 중 하나라도 231-1의 값이 입력되도 랜선을 1cm씩 자른다면랜선의 개수 카운팅을 할 때 int형의 최대 범위를 초과해버리니랜선 개수 변수를 최소 long형을 사용하여야 한다. 예시 231-1, 1이 입력 됐을 경우 1cm 길이로 자를 경우랜선의 개수는 231-1 + 1 = 231개가 된다. 문제 풀이이 문제는 이진 탐색(Binary Search)를 사용해야 한다.시간 제한이 2초이기 때문에 순차 탐색을 하면 시간 초과가 난다. 순차 탐색은 최악의 경우 시간 복잡도가 n이지만 이진 탐색은 log n이다. 탐색 조건각 리스트의 값과 중간 값을 나눈 값의 몫을 카운팅하여 더한 값을 이용하여야 한다. 카운트가 필요 갯수보다 적을 경우 자를 랜선의 길이를 줄여야 하고 반대로 갯수가 많을 경우 자를 랜선의 길이를 늘려야 한다. 갯수가 일치해도 이상의 값을 허용하므로 최대 길이를 구하기 위해자를 랜선이 길이를 늘려야 한다. 코드 1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.*;public class Main { public static void main(String[] args) { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); try { String[] input = br.readLine().split(\" \"); int K = Integer.parseInt(input[0]); int N = Integer.parseInt(input[1]); int haveMax = 0; long maxHeight = 0; int[] lan_List = new int[K]; for (int i = 0; i &lt; K; i++) { lan_List[i] = Integer.parseInt(br.readLine()); haveMax = Math.max(lan_List[i], haveMax); } long mid, left = 1, right = haveMax; long cnt = 0; while (right &gt;= left) { mid = (right + left) / 2; for (int j = 0; j &lt; K; j++) { cnt += lan_List[j] / mid; } if (cnt &gt;= N) { // 필요한 수량보다 같거나 더 많을 경우 maxHeight = Math.max(mid, maxHeight); left = mid + 1; } else { // 필요한 수량보다 더 적을 경우 right = mid - 1; } cnt = 0; } bw.write(maxHeight + \"\\n\"); bw.flush(); bw.close(); br.close(); } catch (Exception e) { System.out.println(e.getMessage()); } }} 후기이진탐색에 대해 개념은 알고 있었지만 실제로 코드 짜는 것은 처음이어서 좋은 경험이 됐다.처음에 int형 범위를 초과할 줄 몰랐다. 질문 게시판에 들어가서야 알게 됐다.후에 새로운 테스트 값으로 디버깅 과정에서 눈으로 직접 확인했다.이진 탐색 조건 잡는 데 생각보다 애를 먹었다.","link":"/2020/03/06/Q1654/"},{"title":"Java Buffer I/O와 Scanner, Sysout 입출력 시간 비교","text":"Buffer I/O와 Scanner, Sysout 시간 차이 1. Sysout &amp; Scanner1System.out.println(\"Hello World\"); 1234import java.util.Scanner;Scanner scanner = new Scanner(System.in);String input = scanner.nextLine();scanner.close(); 자바를 입문하면 먼저 배우게 되는 입출력 방식이다. 이 방식은 아주 기초적이면서도 간단하다. 하지만 알고리즘 문제를 풀다보면 이것들로 인해서 시간 초과가 되는 경우도 있다. 2. BufferedWriter &amp; BufferedReader많이들 이러한 상황에서 Buffer I/O를 사용하라고 한다. 코드는 아래와 같다. 12345678910111213import java.io.*;BufferedReader br = new BufferedReader(new InputStreamReader(System.in));BufferedWriter bw = new BuffetedWriter(new OutputStreamWriter(System.out));try{ String input = br.readLine(); bw.write(input); bw.flush(); bw.close(); br.close(); }catch(IOException e){ System.out.println(e.getMessage()); } 육안으로만 봐도 이전의 입출력 방식보다 훨씬 입력해야하는 코드가 훨씬 많아진다. 하지만 Buffer를 이용하면서 아주 빠른 입출력 시간을 보여주게 된다. 3. BufferedWriter와 System.out.println() 비교각각 for문을 사용하여 10만번 실행시켰고 호기심에 print()도 포함시켜서 비교해 보았다. 테스트 결과 print()와 println()간의 유의미한 차이도 있었지만 bw.write()가 압도적으로 빠른 속도를 보였다. 차이점은 print()와 println()는 반복문이 돌면서 그때그때 즉시 출력해준다면 bw.write()는 buffer에 모아두었다가 버퍼를 비워주면서 한꺼번에 출력시켜준다. 이 과정에서 시간 차이가 생긴다. 이와 별개로 print()와 println()간 차이는 개행문자에 의한 개행과 메소드에 의한 개행의 시간 차이로 보인다. 유사한 이유로는 C++에서 endl의 개행와 개행문자의 개행 간 시간 차이가 난다고 한다. 테스트 코드는 아래와 같다. 1234567891011121314151617181920212223242526272829303132public class Main { public static void main(String[] args) throws Exception { BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int testCount = 100000; long start = System.currentTimeMillis(); for (int i = 0; i &lt; testCount; i++) { System.out.print(i + \"\\n\"); } long end = System.currentTimeMillis(); double print_time = (end - start) / 1000.0; start = System.currentTimeMillis(); for (int i = 0; i &lt; testCount; i++) { System.out.println(i); } end = System.currentTimeMillis(); double println_time = (end - start) / 1000.0; start = System.currentTimeMillis(); for (int i = 0; i &lt; testCount; i++) { bw.write(i + \"\\n\"); } end = System.currentTimeMillis(); double bw_time = (end - start) / 1000.0; bw.write(\"총 실행 횟수 : \" + testCount + \"회\\n\"); bw.write(\"print() 실행시간 : \" + print_time + \"초\\n\"); bw.write(\"println() 실행시간 : \" + println_time + \"초\\n\"); bw.write(\"BufferedWriter 실행시간 : \" + bw_time + \"초\\n\"); bw.flush(); bw.close(); }} 4. BufferedReader와 Scanner 비교이와 같이 각각 for문을 사용하여 10만번 실행시켜 비교하였다. 테스트 결과 이전의 bw.write()와 println()와는 차원이 다른 차이가 나왔다. 알고리즘 채점 과정에서 수많은 테스트 케이스를 입력받게 되는데 입력 받은 양이 방대해질 경우입력 받다가 시간 초과가 생길 수도 있다는 뜻이다. 테스트 코드는 아래와 같다. 123456789101112131415161718192021222324252627282930313233import java.io.*;import java.util.*;public class Main { public static void main(String[] args) throws Exception { Scanner scanner = new Scanner(System.in); BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int testCount = 100000; scanner.nextLine(); long start = System.currentTimeMillis(); int temp = 0; for (int i = 0; i &lt; testCount; i++) { temp = scanner.nextInt(); } long end = System.currentTimeMillis(); double scanner_time = (end - start) / 1000.0; scanner.close(); br.readLine(); start = System.currentTimeMillis(); for (int i = 0; i &lt; testCount; i++) { temp = Integer.parseInt(br.readLine()); } end = System.currentTimeMillis(); double br_time = (end - start) / 1000.0; bw.write(\"총 실행 횟수 : \" + testCount + \"회\\n\"); bw.write(\"println() 실행시간 : \" + scanner_time + \"초\\n\"); bw.write(\"BufferedWriter 실행시간 : \" + br_time + \"초\\n\"); bw.flush(); bw.close(); }} 5. 결론알고리즘과 같이 방대한 양의 입출력이 필요할 땐 Buffer I/O를 활용하자.","link":"/2020/03/07/io-time-difference/"},{"title":"10250번 - ACM 호텔","text":"(문제 출처) 난이도 : 브론즈 3(solved.ac 기준) 언어 : java 문제 요약 H x W형태 호텔에서 엘리베이터와 가장 가까운 순으로 배정하는 프로그램을 작성한다.(단, 엘리베이터를 타고 이동하는 거리는 신경 쓰지 않지만 걷는 거리가 같을 때에는 아래층의 방을 더 선호한다) 유의 사항T의 최대 범위가 정해져있지 않다.따라서 2중 반복문을 사용했을 때 최악의 경우 시간초과가 날 우려가 있다. 예시 모든 케이스가 H = 99, W = 99, N = 9801 일 때결과 값을 출력하기 위해서는 9801 * T 번의 for문을 실행하여야 한다. 문제 풀이이 문제는 간단한 연산으로도 문제를 풀 수 있다.층 순으로 배정하는 것이 아닌 엘리베이터와 가까운 순으로 배정해야한다. 연산 방법 N과 H의 나머지 연산을 통해 대상의 층을 파악한다. N와 H의 몫 연산을 통해 대상의 호수를 파악한다. 이렇게 연산한다면 N 이전의 모든 사람을 시뮬레이션 해줄 필요 없이 배정할 수 있다. 코드 1234567891011121314151617181920212223242526272829303132333435import java.io.*;import java.util.StringTokenizer;public class Main { public static void main(String[] args) throws Exception { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); try { int T = Integer.parseInt(br.readLine()); StringTokenizer st; int H, W, N, Y, X; for (int i = 0; i &lt; T; i++) { st = new StringTokenizer(br.readLine()); H = Integer.parseInt(st.nextToken()); W = Integer.parseInt(st.nextToken()); N = Integer.parseInt(st.nextToken()); Y = N % H; X = N / H + 1; if (Y == 0) { Y = H; X -= 1; } if (X &lt; 10) bw.write(Y + \"0\" + X + \"\\n\"); else bw.write(Y + \"\" + X + \"\\n\"); bw.flush(); } bw.close(); br.close(); } catch (IOException e) { } }} 후기간단한 연산으로 풀 수 있지만 자칫 쉽게 생각하면 틀릴 수 있는 문제","link":"/2020/03/08/Q10250/"}],"tags":[{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"baeakjoon","slug":"baeakjoon","link":"/tags/baeakjoon/"},{"name":"1654번","slug":"1654번","link":"/tags/1654%EB%B2%88/"},{"name":"이진탐색","slug":"이진탐색","link":"/tags/%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/"},{"name":"binary_search","slug":"binary-search","link":"/tags/binary-search/"},{"name":"10250번","slug":"10250번","link":"/tags/10250%EB%B2%88/"},{"name":"Scanner","slug":"Scanner","link":"/tags/Scanner/"},{"name":"Sysout","slug":"Sysout","link":"/tags/Sysout/"},{"name":"BufferedWriter","slug":"BufferedWriter","link":"/tags/BufferedWriter/"},{"name":"BufferedReader","slug":"BufferedReader","link":"/tags/BufferedReader/"},{"name":"BufferI/O","slug":"BufferI-O","link":"/tags/BufferI-O/"}],"categories":[{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"baekjoon","slug":"algorithm/baekjoon","link":"/categories/algorithm/baekjoon/"},{"name":"knowledge","slug":"algorithm/knowledge","link":"/categories/algorithm/knowledge/"}]}