{"pages":[],"posts":[{"title":"1654번 - 랜선 자르기","text":"(문제 출처) 난이도 : 실버 3(solved.ac 기준) 언어 : java 문제 요약 N개의 랜선을 일정 길이 만큼 잘라서 K개 이상이 나오는 최대 길이를 구하라.(단, 이미 자른 랜선은 붙일 수 없다.) 유의 사항입력 조건 중 랜선의 길이가 int형의 최대 범위인 231-1까지다.2개 이상의 랜선 중 하나라도 231-1의 값이 입력되도 랜선을 1cm씩 자른다면랜선의 개수 카운팅을 할 때 int형의 최대 범위를 초과해버리니랜선 개수 변수를 최소 long형을 사용하여야 한다. 예시 231-1, 1이 입력 됐을 경우 1cm 길이로 자를 경우랜선의 개수는 231-1 + 1 = 231개가 된다. 문제 풀이이 문제는 이진 탐색(Binary Search)를 사용해야 한다.시간 제한이 2초이기 때문에 순차 탐색을 하면 시간 초과가 난다. 순차 탐색은 최악의 경우 시간 복잡도가 n이지만 이진 탐색은 log n이다. 탐색 조건각 리스트의 값과 중간 값을 나눈 값의 몫을 카운팅하여 더한 값을 이용하여야 한다. 카운트가 필요 갯수보다 적을 경우 자를 랜선의 길이를 줄여야 하고 반대로 갯수가 많을 경우 자를 랜선의 길이를 늘려야 한다. 갯수가 일치해도 이상의 값을 허용하므로 최대 길이를 구하기 위해자를 랜선이 길이를 늘려야 한다. 코드 1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.*;public class Main { public static void main(String[] args) { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); try { String[] input = br.readLine().split(\" \"); int K = Integer.parseInt(input[0]); int N = Integer.parseInt(input[1]); int haveMax = 0; long maxHeight = 0; int[] lan_List = new int[K]; for (int i = 0; i &lt; K; i++) { lan_List[i] = Integer.parseInt(br.readLine()); haveMax = Math.max(lan_List[i], haveMax); } long mid, left = 1, right = haveMax; long cnt = 0; while (right &gt;= left) { mid = (right + left) / 2; for (int j = 0; j &lt; K; j++) { cnt += lan_List[j] / mid; } if (cnt &gt;= N) { // 필요한 수량보다 같거나 더 많을 경우 maxHeight = Math.max(mid, maxHeight); left = mid + 1; } else { // 필요한 수량보다 더 적을 경우 right = mid - 1; } cnt = 0; } bw.write(maxHeight + \"\\n\"); bw.flush(); bw.close(); br.close(); } catch (Exception e) { System.out.println(e.getMessage()); } }} 후기이진탐색에 대해 개념은 알고 있었지만 실제로 코드 짜는 것은 처음이어서 좋은 경험이 됐다.처음에 int형 범위를 초과할 줄 몰랐다. 질문 게시판에 들어가서야 알게 됐다.후에 새로운 테스트 값으로 디버깅 과정에서 눈으로 직접 확인했다.이진 탐색 조건 잡는 데 생각보다 애를 먹었다.","link":"/2020/03/06/Q1654/"},{"title":"Java Buffer I/O와 Scanner, Sysout 입출력 시간 비교","text":"Buffer I/O와 Scanner, Sysout 시간 차이 1. Sysout &amp; Scanner1System.out.println(\"Hello World\"); 1234import java.util.Scanner;Scanner scanner = new Scanner(System.in);String input = scanner.nextLine();scanner.close(); 자바를 입문하면 먼저 배우게 되는 입출력 방식이다. 이 방식은 아주 기초적이면서도 간단하다. 하지만 알고리즘 문제를 풀다보면 이것들로 인해서 시간 초과가 되는 경우도 있다. 2. BufferedWriter &amp; BufferedReader많이들 이러한 상황에서 Buffer I/O를 사용하라고 한다. 코드는 아래와 같다. 12345678910111213import java.io.*;BufferedReader br = new BufferedReader(new InputStreamReader(System.in));BufferedWriter bw = new BuffetedWriter(new OutputStreamWriter(System.out));try{ String input = br.readLine(); bw.write(input); bw.flush(); bw.close(); br.close(); }catch(IOException e){ System.out.println(e.getMessage()); } 육안으로만 봐도 이전의 입출력 방식보다 훨씬 입력해야하는 코드가 훨씬 많아진다. 하지만 Buffer를 이용하면서 아주 빠른 입출력 시간을 보여주게 된다. 3. BufferedWriter와 System.out.println() 비교각각 for문을 사용하여 10만번 실행시켰고 호기심에 print()도 포함시켜서 비교해 보았다. 테스트 결과 print()와 println()간의 유의미한 차이도 있었지만 bw.write()가 압도적으로 빠른 속도를 보였다. 차이점은 print()와 println()는 반복문이 돌면서 그때그때 즉시 출력해준다면 bw.write()는 buffer에 모아두었다가 버퍼를 비워주면서 한꺼번에 출력시켜준다. 이 과정에서 시간 차이가 생긴다. 이와 별개로 print()와 println()간 차이는 개행문자에 의한 개행과 메소드에 의한 개행의 시간 차이로 보인다. 유사한 이유로는 C++에서 endl의 개행와 개행문자의 개행 간 시간 차이가 난다고 한다. 테스트 코드는 아래와 같다. 1234567891011121314151617181920212223242526272829303132public class Main { public static void main(String[] args) throws Exception { BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int testCount = 100000; long start = System.currentTimeMillis(); for (int i = 0; i &lt; testCount; i++) { System.out.print(i + \"\\n\"); } long end = System.currentTimeMillis(); double print_time = (end - start) / 1000.0; start = System.currentTimeMillis(); for (int i = 0; i &lt; testCount; i++) { System.out.println(i); } end = System.currentTimeMillis(); double println_time = (end - start) / 1000.0; start = System.currentTimeMillis(); for (int i = 0; i &lt; testCount; i++) { bw.write(i + \"\\n\"); } end = System.currentTimeMillis(); double bw_time = (end - start) / 1000.0; bw.write(\"총 실행 횟수 : \" + testCount + \"회\\n\"); bw.write(\"print() 실행시간 : \" + print_time + \"초\\n\"); bw.write(\"println() 실행시간 : \" + println_time + \"초\\n\"); bw.write(\"BufferedWriter 실행시간 : \" + bw_time + \"초\\n\"); bw.flush(); bw.close(); }} 4. BufferedReader와 Scanner 비교이와 같이 각각 for문을 사용하여 10만번 실행시켜 비교하였다. 테스트 결과 이전의 bw.write()와 println()와는 차원이 다른 차이가 나왔다. 알고리즘 채점 과정에서 수많은 테스트 케이스를 입력받게 되는데 입력 받은 양이 방대해질 경우입력 받다가 시간 초과가 생길 수도 있다는 뜻이다. 테스트 코드는 아래와 같다. 123456789101112131415161718192021222324252627282930313233import java.io.*;import java.util.*;public class Main { public static void main(String[] args) throws Exception { Scanner scanner = new Scanner(System.in); BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int testCount = 100000; scanner.nextLine(); long start = System.currentTimeMillis(); int temp = 0; for (int i = 0; i &lt; testCount; i++) { temp = scanner.nextInt(); } long end = System.currentTimeMillis(); double scanner_time = (end - start) / 1000.0; scanner.close(); br.readLine(); start = System.currentTimeMillis(); for (int i = 0; i &lt; testCount; i++) { temp = Integer.parseInt(br.readLine()); } end = System.currentTimeMillis(); double br_time = (end - start) / 1000.0; bw.write(\"총 실행 횟수 : \" + testCount + \"회\\n\"); bw.write(\"println() 실행시간 : \" + scanner_time + \"초\\n\"); bw.write(\"BufferedWriter 실행시간 : \" + br_time + \"초\\n\"); bw.flush(); bw.close(); }} 5. 결론알고리즘과 같이 방대한 양의 입출력이 필요할 땐 Buffer I/O를 활용하자.","link":"/2020/03/07/io-time-difference/"},{"title":"10250번 - ACM 호텔","text":"(문제 출처) 난이도 : 브론즈 3(solved.ac 기준) 언어 : java 문제 요약 H x W형태 호텔에서 엘리베이터와 가장 가까운 순으로 배정하는 프로그램을 작성한다.(단, 엘리베이터를 타고 이동하는 거리는 신경 쓰지 않지만 걷는 거리가 같을 때에는 아래층의 방을 더 선호한다) 유의 사항T의 최대 범위가 정해져있지 않다.따라서 2중 반복문을 사용했을 때 최악의 경우 시간초과가 날 우려가 있다. 예시 모든 케이스가 H = 99, W = 99, N = 9801 일 때결과 값을 출력하기 위해서는 9801 * T 번의 for문을 실행하여야 한다. 문제 풀이이 문제는 간단한 연산으로도 문제를 풀 수 있다.층 순으로 배정하는 것이 아닌 엘리베이터와 가까운 순으로 배정해야한다. 연산 방법 N과 H의 나머지 연산을 통해 대상의 층을 파악한다. N와 H의 몫 연산을 통해 대상의 호수를 파악한다. 이렇게 연산한다면 N 이전의 모든 사람을 시뮬레이션 해줄 필요 없이 배정할 수 있다. 코드 1234567891011121314151617181920212223242526272829303132333435import java.io.*;import java.util.StringTokenizer;public class Main { public static void main(String[] args) throws Exception { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); try { int T = Integer.parseInt(br.readLine()); StringTokenizer st; int H, W, N, Y, X; for (int i = 0; i &lt; T; i++) { st = new StringTokenizer(br.readLine()); H = Integer.parseInt(st.nextToken()); W = Integer.parseInt(st.nextToken()); N = Integer.parseInt(st.nextToken()); Y = N % H; X = N / H + 1; if (Y == 0) { Y = H; X -= 1; } if (X &lt; 10) bw.write(Y + \"0\" + X + \"\\n\"); else bw.write(Y + \"\" + X + \"\\n\"); bw.flush(); } bw.close(); br.close(); } catch (IOException e) { } }} 후기간단한 연산으로 풀 수 있지만 자칫 쉽게 생각하면 틀릴 수 있는 문제","link":"/2020/03/08/Q10250/"},{"title":"1074번 - Z","text":"(문제 출처) 난이도 : 실버 1(solved.ac 기준) 언어 : java 문제 요약 N = 1일 때 배열을 Z 모양 순으로 탐색하고 N &gt; 1일 경우배열을 4등분한 후 재귀적으로 순서대로 방문하고 (r,c)을 몇 번째로 방문하는지 구하여라. 유의 사항재귀함수를 쓰는 만큼 기저 조건을 잘 써주자.그리고 (r,c)는 (x,y)가 아닌 (y,x)이다. 따라서 (c,r)로 생각하여 풀자.(단, 0 &lt;= r,c &lt; 2N) 문제 풀이이 문제는 재귀함수를 사용하여 분할정복하여야 한다.N&gt;1 일 때 2x2 배열이 될 때 문제의 그림처럼 계속하여 분할해주어야하기 때문이다.예시) 8x8 -&gt; 4x4(4개) -&gt; 2x2(16개)재귀함수를 실행하면서 2x2인지 확인을 하고 아닐 경우 2x2이 될 때까지 재귀함수를 실행한다.그리고 2x2 배열을 Z 모양으로 탐색하여 (r,c)을 찾을 때까지 카운팅 해준다. 나는 여기서 4등분한 배열의 각 끝점이 r이나 c보다 작을 경우 더 분할하지 않고 바로 전체를 카운팅해주었다.왜 그런지는 그림으로 설명해주겠다. N=3, r=6, c=2일 경우 배열 a는 23 = 8인 a[8][8]의 배열을 가지게 된다. 그리고 찾아야할 좌표는 (c, r)인 (2,6)이다. N&gt;1이기 때문에 배열을 4등분하여 각 끝점이 r이나 c보다 작을 경우를 살펴본다. 찾는 좌표 위치가 3사분면이기 때문에 1,2사분면은 3사분면보다 y값이 작을 수 밖에 없다.(단, 그래프상 y는 아래로 갈수록 커짐) 따라서 1,2사분면은 더이상 분할하여 재귀함수를 실행할 필요도 없이 모두 탐색했다고 가정하여 카운팅해준다. 현재 8x8배열이라서 2개의 4x4배열이 만들어지고 하나의 4x4의 배열은 4개의 2x2배열이 만들어진다. 2x2배열의 원소 수는 총 4개이기에 한사분면의 원소 수는 4*4 = 16개가 된다. 1,2사분면의 원소 수의 합을 더하면 16*2 = 32가 카운팅 된다. 이제는 3사분면을 탐색해야한다. 3사분면은 4x4배열이기 때문에 또다시 분할시켜준다. 분할 결과 찾는 좌표가 4사분면에 있기에 1,2사분면의 경우 y값이 작고 3사분면의 경우 x값이 작다. (4사분면 대비) 따라서 1,2,3사분면은 더이상 분할하여 재귀함수를 실행할 필요도 없이 모두 탐색했다고 가정하여 카운팅해준다. 이제는 4x4배열이라서 총 3개의 2x2배열이 만들어진다. 2x2배열의 원소 수는 총 4개이다. 따라서 총 원소 수는 4*3 = 12개가 된다. 이전에 카운트한 32에서 12를 더하여 총 44번의 탐색을 한 셈 치는 것이다. 이제 남은 4사분면을 탐색해주어야하지만 2x2배열은 Z방향으로 탐색해준다. 처음에 바로 원하는 좌표가 탐색이 되었기 때문에 카운팅하지 않고 탐색을 끝낸다. 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.io.*;import java.util.*;public class Main { static int N, r, c, cnt = 0; static boolean isFind = false; private static void find(int startX, int startY, int endX, int endY) { if ((endY - startY + 1) / 2 &gt;= 2) { int x1, x2, y1, y2; for (int i = 0; i &lt; 4; i++) { if (i % 2 == 1) { x1 = (endX + startX) / 2 + 1; x2 = endX; } else { x1 = startX; x2 = (endX + startX) / 2; } if (i &gt; 1) { y1 = (endY + startY) / 2 + 1; y2 = endY; } else { y1 = startY; y2 = (endY + startY) / 2; } if (y2 &lt; r || x2 &lt; c) { cnt += (x2 - x1 + 1) * (y2 - y1 + 1); } else find(x1, y1, x2, y2); if (isFind) return; } } else { for (int i = startY; i &lt; endY + 1; i++) { for (int j = startX; j &lt; endX + 1; j++) { if (i == r &amp;&amp; j == c) { isFind = true; return; } else cnt++; } } } } public static void main(String[] args) throws Exception { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); StringTokenizer st = new StringTokenizer(br.readLine()); N = Integer.parseInt(st.nextToken()); r = Integer.parseInt(st.nextToken()); c = Integer.parseInt(st.nextToken()); int maxSize = (int) Math.pow(2, N) - 1; find(0, 0, maxSize, maxSize); bw.write(cnt + \"\\n\"); bw.flush(); bw.close(); br.close(); }} 후기분할을 어떻게 해야할 것인가부터 재귀를 어떻게 정상적으로 실행할 것인가까지 고민할 수 있게 만들어 준 문제기존에는 처음부터 좌표를 찾을 때까지 분할하여 탐색하는 방식으로 풀었지만 생각보다 시간이 오래 걸려서 추가로 위의 조건을 추가하여 주었다.","link":"/2020/03/24/Q1074/"}],"tags":[{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"baeakjoon","slug":"baeakjoon","link":"/tags/baeakjoon/"},{"name":"1654번","slug":"1654번","link":"/tags/1654%EB%B2%88/"},{"name":"이진탐색","slug":"이진탐색","link":"/tags/%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/"},{"name":"binary_search","slug":"binary-search","link":"/tags/binary-search/"},{"name":"10250번","slug":"10250번","link":"/tags/10250%EB%B2%88/"},{"name":"Scanner","slug":"Scanner","link":"/tags/Scanner/"},{"name":"Sysout","slug":"Sysout","link":"/tags/Sysout/"},{"name":"BufferedWriter","slug":"BufferedWriter","link":"/tags/BufferedWriter/"},{"name":"BufferedReader","slug":"BufferedReader","link":"/tags/BufferedReader/"},{"name":"BufferI/O","slug":"BufferI-O","link":"/tags/BufferI-O/"},{"name":"1074번","slug":"1074번","link":"/tags/1074%EB%B2%88/"},{"name":"재귀","slug":"재귀","link":"/tags/%EC%9E%AC%EA%B7%80/"},{"name":"분할정복","slug":"분할정복","link":"/tags/%EB%B6%84%ED%95%A0%EC%A0%95%EB%B3%B5/"}],"categories":[{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"baekjoon","slug":"algorithm/baekjoon","link":"/categories/algorithm/baekjoon/"},{"name":"knowledge","slug":"algorithm/knowledge","link":"/categories/algorithm/knowledge/"},{"name":"bronze","slug":"algorithm/baekjoon/bronze","link":"/categories/algorithm/baekjoon/bronze/"},{"name":"silver","slug":"algorithm/baekjoon/silver","link":"/categories/algorithm/baekjoon/silver/"}]}