<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>컴공학부생 INT&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://int31302.github.io/"/>
  <updated>2020-03-24T08:51:36.715Z</updated>
  <id>https://int31302.github.io/</id>
  
  <author>
    <name>INT31302</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1074번 - Z</title>
    <link href="https://int31302.github.io/2020/03/24/Q1074/"/>
    <id>https://int31302.github.io/2020/03/24/Q1074/</id>
    <published>2020-03-24T05:51:16.000Z</published>
    <updated>2020-03-24T08:51:36.715Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.acmicpc.net/problem/1074">(문제 출처)</a></p><a id="more"></a><ul><li>난이도 : 실버 1(<a href="https://solved.ac/class">solved.ac</a> 기준)</li><li>언어 : java</li></ul><p><img src="/images/1074%EB%B2%88-Z/1.png" alt="문제"></p><ul><li><p>문제 요약</p><blockquote><p><em>N = 1</em>일 때 배열을 Z 모양 순으로 탐색하고 <em>N &gt; 1</em>일 경우<br>배열을 4등분한 후 재귀적으로 순서대로 방문하고 <em>(r,c)</em>을 몇 번째로 방문하는지 구하여라.</p></blockquote></li><li><p>유의 사항<br>재귀함수를 쓰는 만큼 기저 조건을 잘 써주자.<br>그리고 (r,c)는 (x,y)가 아닌 (y,x)이다. 따라서 (c,r)로 생각하여 풀자.<br><strong>(단, 0 &lt;= r,c &lt; 2<sup>N</sup>)</strong></p></li><li><p>문제 풀이<br>이 문제는 <strong>재귀함수</strong>를 사용하여 분할정복하여야 한다.<br>N&gt;1 일 때 2x2 배열이 될 때 문제의 그림처럼 계속하여 분할해주어야하기 때문이다.<br><strong>예시) 8x8 -&gt; 4x4(4개) -&gt; 2x2(16개)</strong><br>재귀함수를 실행하면서 2x2인지 확인을 하고 아닐 경우 2x2이 될 때까지 재귀함수를 실행한다.<br>그리고 2x2 배열을 Z 모양으로 탐색하여 <strong>(r,c)을 찾을 때까지 카운팅 해준다.</strong></p></li></ul><p>나는 여기서 4등분한 배열의 각 끝점이 r이나 c보다 작을 경우 더 분할하지 않고 바로 전체를 카운팅해주었다.<br>왜 그런지는 그림으로 설명해주겠다.</p><p><img src="/images/1074%EB%B2%88-Z/%EC%84%A4%EB%AA%851.png" alt="설명1"><br>N=3, r=6, c=2일 경우 배열 a는 2<sup>3</sup> = 8인 a[8][8]의 배열을 가지게 된다.</p><p>그리고 찾아야할 좌표는 (c, r)인 (2,6)이다.</p><p><img src="/images/1074%EB%B2%88-Z/%EC%84%A4%EB%AA%852.png" alt="설명2"><br>N&gt;1이기 때문에 배열을 4등분하여 각 끝점이 r이나 c보다 작을 경우를 살펴본다.</p><p>찾는 좌표 위치가 3사분면이기 때문에 1,2사분면은 3사분면보다 y값이 작을 수 밖에 없다.<br><strong>(단, 그래프상 y는 아래로 갈수록 커짐)</strong></p><p><img src="/images/1074%EB%B2%88-Z/%EC%84%A4%EB%AA%853.png" alt="설명3"><br>따라서 1,2사분면은 더이상 분할하여 재귀함수를 실행할 필요도 없이 모두 탐색했다고 가정하여 카운팅해준다.</p><p><img src="/images/1074%EB%B2%88-Z/%EC%84%A4%EB%AA%854.png" alt="설명4"><br>현재 8x8배열이라서 2개의 4x4배열이 만들어지고 하나의 4x4의 배열은 4개의 2x2배열이 만들어진다.</p><p>2x2배열의 원소 수는 총 4개이기에 한사분면의 원소 수는 4*4 = 16개가 된다.</p><p><img src="/images/1074%EB%B2%88-Z/%EC%84%A4%EB%AA%855.png" alt="설명5"><br>1,2사분면의 원소 수의 합을 더하면 16*2 = 32가 카운팅 된다.</p><p>이제는 3사분면을 탐색해야한다.</p><p><img src="/images/1074%EB%B2%88-Z/%EC%84%A4%EB%AA%856.png" alt="설명6"><br>3사분면은 4x4배열이기 때문에 또다시 분할시켜준다.</p><p><img src="/images/1074%EB%B2%88-Z/%EC%84%A4%EB%AA%857.png" alt="설명7"><br>분할 결과 찾는 좌표가 4사분면에 있기에 1,2사분면의 경우 y값이 작고 3사분면의 경우 x값이 작다.</p><p><strong>(4사분면 대비)</strong></p><p><img src="/images/1074%EB%B2%88-Z/%EC%84%A4%EB%AA%858.png" alt="설명8"><br>따라서 1,2,3사분면은 더이상 분할하여 재귀함수를 실행할 필요도 없이 모두 탐색했다고 가정하여 카운팅해준다.</p><p><img src="/images/1074%EB%B2%88-Z/%EC%84%A4%EB%AA%859.png" alt="설명9"><br>이제는 4x4배열이라서 총 3개의 2x2배열이 만들어진다.</p><p><img src="/images/1074%EB%B2%88-Z/%EC%84%A4%EB%AA%8510.png" alt="설명10"><br>2x2배열의 원소 수는 총 4개이다. 따라서 총 원소 수는 4*3 = 12개가 된다.</p><p>이전에 카운트한 32에서 12를 더하여 총 44번의 탐색을 한 셈 치는 것이다.</p><p><img src="/images/1074%EB%B2%88-Z/%EC%84%A4%EB%AA%8511.png" alt="설명11"><br>이제 남은 4사분면을 탐색해주어야하지만 2x2배열은 Z방향으로 탐색해준다.</p><p><img src="/images/1074%EB%B2%88-Z/%EC%84%A4%EB%AA%8512.png" alt="설명12"><br>처음에 바로 원하는 좌표가 탐색이 되었기 때문에 카운팅하지 않고 탐색을 끝낸다.</p><ul><li>코드<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> N, r, c, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> isFind = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> endX, <span class="keyword">int</span> endY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((endY - startY + <span class="number">1</span>) / <span class="number">2</span> &gt;= <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> x1, x2, y1, y2;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    x1 = (endX + startX) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                    x2 = endX;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    x1 = startX;</span><br><span class="line">                    x2 = (endX + startX) / <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    y1 = (endY + startY) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                    y2 = endY;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    y1 = startY;</span><br><span class="line">                    y2 = (endY + startY) / <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (y2 &lt; r || x2 &lt; c) &#123;</span><br><span class="line">                    cnt += (x2 - x1 + <span class="number">1</span>) * (y2 - y1 + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    find(x1, y1, x2, y2);</span><br><span class="line">                <span class="keyword">if</span> (isFind)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = startY; i &lt; endY + <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = startX; j &lt; endX + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == r &amp;&amp; j == c) &#123;</span><br><span class="line">                        isFind = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(br.readLine());</span><br><span class="line">        N = Integer.parseInt(st.nextToken());</span><br><span class="line">        r = Integer.parseInt(st.nextToken());</span><br><span class="line">        c = Integer.parseInt(st.nextToken());</span><br><span class="line">        <span class="keyword">int</span> maxSize = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, N) - <span class="number">1</span>;</span><br><span class="line">        find(<span class="number">0</span>, <span class="number">0</span>, maxSize, maxSize);</span><br><span class="line">        bw.write(cnt + <span class="string">"\n"</span>);</span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>후기<br>분할을 어떻게 해야할 것인가부터 재귀를 어떻게 정상적으로 실행할 것인가까지 고민할 수 있게 만들어 준 문제<br>기존에는 처음부터 좌표를 찾을 때까지 분할하여 탐색하는 방식으로 풀었지만 생각보다 시간이 오래 걸려서 추가로 위의 조건을 추가하여 주었다.</li></ul><p><img src="/images/1074%EB%B2%88-Z/2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1074&quot;&gt;(문제 출처)&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://int31302.github.io/categories/algorithm/"/>
    
      <category term="baekjoon" scheme="https://int31302.github.io/categories/algorithm/baekjoon/"/>
    
      <category term="silver" scheme="https://int31302.github.io/categories/algorithm/baekjoon/silver/"/>
    
    
      <category term="algorithm" scheme="https://int31302.github.io/tags/algorithm/"/>
    
      <category term="baeakjoon" scheme="https://int31302.github.io/tags/baeakjoon/"/>
    
      <category term="1074번" scheme="https://int31302.github.io/tags/1074%EB%B2%88/"/>
    
      <category term="재귀" scheme="https://int31302.github.io/tags/%EC%9E%AC%EA%B7%80/"/>
    
      <category term="분할정복" scheme="https://int31302.github.io/tags/%EB%B6%84%ED%95%A0%EC%A0%95%EB%B3%B5/"/>
    
  </entry>
  
  <entry>
    <title>10250번 - ACM 호텔</title>
    <link href="https://int31302.github.io/2020/03/08/Q10250/"/>
    <id>https://int31302.github.io/2020/03/08/Q10250/</id>
    <published>2020-03-08T14:10:09.000Z</published>
    <updated>2020-03-08T16:28:09.922Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.acmicpc.net/problem/10250">(문제 출처)</a></p><a id="more"></a><ul><li>난이도 : 브론즈 3(<a href="https://solved.ac/class">solved.ac</a> 기준)</li><li>언어 : java</li></ul><p><img src="/images/10250%EB%B2%88-ACM-%ED%98%B8%ED%85%94/1.png" alt=""><br><img src="/images/10250%EB%B2%88-ACM-%ED%98%B8%ED%85%94/2.png" alt="문제"></p><ul><li>문제 요약<blockquote><p><em>H x W</em>형태 호텔에서 엘리베이터와 가장 가까운 순으로 배정하는 프로그램을 작성한다.<br><strong>(단, 엘리베이터를 타고 이동하는 거리는 신경 쓰지 않지만 걷는 거리가 같을 때에는 아래층의 방을 더 선호한다)</strong></p></blockquote></li></ul><ul><li><p>유의 사항<br>T의 최대 범위가 정해져있지 않다.<br>따라서 2중 반복문을 사용했을 때 최악의 경우 시간초과가 날 우려가 있다.</p><ul><li>예시<blockquote><p>모든 케이스가 H = 99, W = 99, N = 9801 일 때<br>결과 값을 출력하기 위해서는 9801 * T 번의 for문을 실행하여야 한다.</p></blockquote></li></ul></li><li><p>문제 풀이<br>이 문제는 간단한 연산으로도 문제를 풀 수 있다.<br>층 순으로 배정하는 것이 아닌 <strong>엘리베이터와 가까운 순으로 배정</strong>해야한다.</p><ul><li>연산 방법<ul><li>N과 H의 <strong>나머지 연산</strong>을 통해 <strong>대상의 층</strong>을 파악한다.</li><li>N와 H의 <strong>몫 연산</strong>을 통해 <strong>대상의 호수</strong>를 파악한다.</li></ul></li></ul></li></ul><p>이렇게 연산한다면 N 이전의 모든 사람을 시뮬레이션 해줄 필요 없이 배정할 수 있다.</p><ul><li><p>코드</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> T = Integer.parseInt(br.readLine());</span><br><span class="line">            StringTokenizer st;</span><br><span class="line">            <span class="keyword">int</span> H, W, N, Y, X;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">                st = <span class="keyword">new</span> StringTokenizer(br.readLine());</span><br><span class="line">                H = Integer.parseInt(st.nextToken());</span><br><span class="line">                W = Integer.parseInt(st.nextToken());</span><br><span class="line">                N = Integer.parseInt(st.nextToken());</span><br><span class="line">                Y = N % H;</span><br><span class="line">                X = N / H + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (Y == <span class="number">0</span>) &#123;</span><br><span class="line">                    Y = H;</span><br><span class="line">                    X -= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (X &lt; <span class="number">10</span>)</span><br><span class="line">                    bw.write(Y + <span class="string">"0"</span> + X + <span class="string">"\n"</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    bw.write(Y + <span class="string">""</span> + X + <span class="string">"\n"</span>);</span><br><span class="line">                bw.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            bw.close();</span><br><span class="line">            br.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>후기<br>간단한 연산으로 풀 수 있지만 자칫 쉽게 생각하면 틀릴 수 있는 문제<br><img src="/images/10250%EB%B2%88-ACM-%ED%98%B8%ED%85%94/3.png" alt=""></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/10250&quot;&gt;(문제 출처)&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://int31302.github.io/categories/algorithm/"/>
    
      <category term="baekjoon" scheme="https://int31302.github.io/categories/algorithm/baekjoon/"/>
    
      <category term="bronze" scheme="https://int31302.github.io/categories/algorithm/baekjoon/bronze/"/>
    
    
      <category term="algorithm" scheme="https://int31302.github.io/tags/algorithm/"/>
    
      <category term="baeakjoon" scheme="https://int31302.github.io/tags/baeakjoon/"/>
    
      <category term="이진탐색" scheme="https://int31302.github.io/tags/%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/"/>
    
      <category term="10250번" scheme="https://int31302.github.io/tags/10250%EB%B2%88/"/>
    
  </entry>
  
  <entry>
    <title>Java Buffer I/O와 Scanner, Sysout 입출력 시간 비교</title>
    <link href="https://int31302.github.io/2020/03/07/io-time-difference/"/>
    <id>https://int31302.github.io/2020/03/07/io-time-difference/</id>
    <published>2020-03-06T16:59:12.000Z</published>
    <updated>2020-03-08T14:10:58.457Z</updated>
    
    <content type="html"><![CDATA[<p>Buffer I/O와 Scanner, Sysout 시간 차이</p><a id="more"></a><h2 id="1-Sysout-amp-Scanner"><a href="#1-Sysout-amp-Scanner" class="headerlink" title="1. Sysout &amp; Scanner"></a>1. Sysout &amp; Scanner</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Hello World"</span>);</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String input = scanner.nextLine();</span><br><span class="line">scanner.close();</span><br></pre></td></tr></table></figure><p>자바를 입문하면 먼저 배우게 되는 입출력 방식이다. 이 방식은 아주 기초적이면서도 간단하다.</p><p>하지만 알고리즘 문제를 풀다보면 이것들로 인해서 시간 초과가 되는 경우도 있다.</p><h2 id="2-BufferedWriter-amp-BufferedReader"><a href="#2-BufferedWriter-amp-BufferedReader" class="headerlink" title="2. BufferedWriter &amp; BufferedReader"></a>2. BufferedWriter &amp; BufferedReader</h2><p>많이들 이러한 상황에서 Buffer I/O를 사용하라고 한다. 코드는 아래와 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BuffetedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">       String input = br.readLine();</span><br><span class="line">        bw.write(input);</span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>육안으로만 봐도 이전의 입출력 방식보다 훨씬 입력해야하는 코드가 훨씬 많아진다.</p><p>하지만 Buffer를 이용하면서 아주 빠른 입출력 시간을 보여주게 된다.</p><h2 id="3-BufferedWriter와-System-out-println-비교"><a href="#3-BufferedWriter와-System-out-println-비교" class="headerlink" title="3. BufferedWriter와 System.out.println() 비교"></a>3. BufferedWriter와 System.out.println() 비교</h2><p>각각 for문을 사용하여 10만번 실행시켰고 호기심에 print()도 포함시켜서 비교해 보았다.</p><p>테스트 결과<br><img src="/images/Java-io-%EB%B9%84%EA%B5%90/1.png" alt="비교결과"></p><p>print()와 println()간의 유의미한 차이도 있었지만 bw.write()가 압도적으로 빠른 속도를 보였다.</p><p>차이점은 print()와 println()는 반복문이 돌면서 그때그때 즉시 출력해준다면</p><p>bw.write()는 buffer에 모아두었다가 버퍼를 비워주면서 한꺼번에 출력시켜준다.</p><p>이 과정에서 시간 차이가 생긴다.</p><p>이와 별개로 print()와 println()간 차이는 개행문자에 의한 개행과 메소드에 의한 개행의 시간 차이로 보인다.</p><p>유사한 이유로는 C++에서 endl의 개행와 개행문자의 개행 간 시간 차이가 난다고 한다.</p><p>테스트 코드는 아래와 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">        <span class="keyword">int</span> testCount = <span class="number">100000</span>;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testCount; i++) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">double</span> print_time = (end - start) / <span class="number">1000.0</span>;</span><br><span class="line"></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testCount; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">double</span> println_time = (end - start) / <span class="number">1000.0</span>;</span><br><span class="line"></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testCount; i++) &#123;</span><br><span class="line">            bw.write(i + <span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">double</span> bw_time = (end - start) / <span class="number">1000.0</span>;</span><br><span class="line">        bw.write(<span class="string">"총 실행 횟수 : "</span> + testCount + <span class="string">"회\n"</span>);</span><br><span class="line">        bw.write(<span class="string">"print() 실행시간 : "</span> + print_time + <span class="string">"초\n"</span>);</span><br><span class="line">        bw.write(<span class="string">"println() 실행시간 : "</span> + println_time + <span class="string">"초\n"</span>);</span><br><span class="line">        bw.write(<span class="string">"BufferedWriter 실행시간 : "</span> + bw_time + <span class="string">"초\n"</span>);</span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-BufferedReader와-Scanner-비교"><a href="#4-BufferedReader와-Scanner-비교" class="headerlink" title="4. BufferedReader와 Scanner 비교"></a>4. BufferedReader와 Scanner 비교</h2><p>이와 같이 각각 for문을 사용하여 10만번 실행시켜 비교하였다.</p><p>테스트 결과<br><img src="/images/Java-io-%EB%B9%84%EA%B5%90/2.png" alt="비교결과"></p><p>이전의 bw.write()와 println()와는 차원이 다른 차이가 나왔다.</p><p>알고리즘 채점 과정에서 수많은 테스트 케이스를 입력받게 되는데 입력 받은 양이 방대해질 경우<br>입력 받다가 시간 초과가 생길 수도 있다는 뜻이다.</p><p>테스트 코드는 아래와 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">        <span class="keyword">int</span> testCount = <span class="number">100000</span>;</span><br><span class="line">        scanner.nextLine();</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testCount; i++) &#123;</span><br><span class="line">            temp = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">double</span> scanner_time = (end - start) / <span class="number">1000.0</span>;</span><br><span class="line">        scanner.close();</span><br><span class="line">        </span><br><span class="line">        br.readLine();</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testCount; i++) &#123;</span><br><span class="line">            temp = Integer.parseInt(br.readLine());</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">double</span> br_time = (end - start) / <span class="number">1000.0</span>;</span><br><span class="line">        bw.write(<span class="string">"총 실행 횟수 : "</span> + testCount + <span class="string">"회\n"</span>);</span><br><span class="line">        bw.write(<span class="string">"println() 실행시간 : "</span> + scanner_time + <span class="string">"초\n"</span>);</span><br><span class="line">        bw.write(<span class="string">"BufferedWriter 실행시간 : "</span> + br_time + <span class="string">"초\n"</span>);</span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-결론"><a href="#5-결론" class="headerlink" title="5. 결론"></a>5. 결론</h2><p>알고리즘과 같이 방대한 양의 입출력이 필요할 땐 Buffer I/O를 활용하자.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Buffer I/O와 Scanner, Sysout 시간 차이&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://int31302.github.io/categories/algorithm/"/>
    
      <category term="knowledge" scheme="https://int31302.github.io/categories/algorithm/knowledge/"/>
    
    
      <category term="Scanner" scheme="https://int31302.github.io/tags/Scanner/"/>
    
      <category term="Sysout" scheme="https://int31302.github.io/tags/Sysout/"/>
    
      <category term="BufferedWriter" scheme="https://int31302.github.io/tags/BufferedWriter/"/>
    
      <category term="BufferedReader" scheme="https://int31302.github.io/tags/BufferedReader/"/>
    
      <category term="BufferI/O" scheme="https://int31302.github.io/tags/BufferI-O/"/>
    
  </entry>
  
  <entry>
    <title>1654번 - 랜선 자르기</title>
    <link href="https://int31302.github.io/2020/03/06/Q1654/"/>
    <id>https://int31302.github.io/2020/03/06/Q1654/</id>
    <published>2020-03-05T17:43:16.000Z</published>
    <updated>2020-03-08T16:28:17.028Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.acmicpc.net/problem/1654">(문제 출처)</a></p><a id="more"></a><ul><li>난이도 : 실버 3(<a href="https://solved.ac/class">solved.ac</a> 기준)</li><li>언어 : java</li></ul><p><img src="/images/1654%EB%B2%88-%EB%9E%9C%EC%84%A0-%EC%9E%90%EB%A5%B4%EA%B8%B0/1.png" alt="문제"></p><ul><li>문제 요약<blockquote><p><em>N</em>개의 랜선을 일정 길이 만큼 잘라서 <em>K</em>개 이상이 나오는 최대 길이를 구하라.<br><strong>(단, 이미 자른 랜선은 붙일 수 없다.)</strong></p></blockquote></li></ul><ul><li><p>유의 사항<br>입력 조건 중 랜선의 길이가 <strong>int형의 최대 범위인 2<sup>31</sup>-1</strong>까지다.<br>2개 이상의 랜선 중 하나라도 2<sup>31</sup>-1의 값이 입력되도 랜선을 1cm씩 자른다면<br>랜선의 개수 카운팅을 할 때 <strong>int형의 최대 범위를 초과</strong>해버리니<br><strong>랜선 개수 변수를 최소 long형을 사용하여야 한다.</strong></p><ul><li>예시<blockquote><p>2<sup>31</sup>-1, 1이 입력 됐을 경우 1cm 길이로 자를 경우<br>랜선의 개수는 2<sup>31</sup>-1 + 1 = <strong>2<sup>31</sup>개</strong>가 된다.</p></blockquote></li></ul></li></ul><ul><li>문제 풀이<br>이 문제는 <strong>이진 탐색(Binary Search)</strong>를 사용해야 한다.<br>시간 제한이 2초이기 때문에 순차 탐색을 하면 <strong>시간 초과</strong>가 난다.<blockquote><p><strong>순차 탐색</strong>은 최악의 경우 시간 복잡도가 <strong>n</strong>이지만 <strong>이진 탐색</strong>은 <strong>log n</strong>이다.</p></blockquote><ul><li>탐색 조건<br><strong>각 리스트의 값과 중간 값을 나눈 값</strong>의 <strong>몫을 카운팅하여 더한 값</strong>을 이용하여야 한다.<ul><li>카운트가 필요 갯수보다 <strong>적을 경우</strong> 자를 랜선의 길이를 <strong>줄여야</strong> 하고</li><li>반대로 갯수가 <strong>많을 경우</strong> 자를 랜선의 길이를 <strong>늘려야</strong> 한다.</li><li>갯수가 <strong>일치</strong>해도 <strong>이상의 값을 허용</strong>하므로 <strong>최대 길이를 구하기 위해</strong><br>자를 랜선이 길이를 <strong>늘려야</strong> 한다.</li></ul></li></ul></li></ul><ul><li><p>코드</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String[] input = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">int</span> K = Integer.parseInt(input[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> N = Integer.parseInt(input[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">int</span> haveMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span>[] lan_List = <span class="keyword">new</span> <span class="keyword">int</span>[K];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i++) &#123;</span><br><span class="line">                lan_List[i] = Integer.parseInt(br.readLine());</span><br><span class="line">                haveMax = Math.max(lan_List[i], haveMax);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> mid, left = <span class="number">1</span>, right = haveMax;</span><br><span class="line">            <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt;= left) &#123;</span><br><span class="line">                mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; j++) &#123;</span><br><span class="line">                    cnt += lan_List[j] / mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt;= N) &#123; <span class="comment">// 필요한 수량보다 같거나 더 많을 경우</span></span><br><span class="line">                    maxHeight = Math.max(mid, maxHeight);</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 필요한 수량보다 더 적을 경우</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bw.write(maxHeight + <span class="string">"\n"</span>);</span><br><span class="line">            bw.flush();</span><br><span class="line">            bw.close();</span><br><span class="line">            br.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>후기<br>이진탐색에 대해 개념은 알고 있었지만 실제로 코드 짜는 것은 처음이어서 좋은 경험이 됐다.<br>처음에 int형 범위를 초과할 줄 몰랐다. 질문 게시판에 들어가서야 알게 됐다.<br>후에 새로운 테스트 값으로 디버깅 과정에서 눈으로 직접 확인했다.<br>이진 탐색 조건 잡는 데 생각보다 애를 먹었다.</p></li></ul><p><img src="/images/1654%EB%B2%88-%EB%9E%9C%EC%84%A0-%EC%9E%90%EB%A5%B4%EA%B8%B0/2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1654&quot;&gt;(문제 출처)&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://int31302.github.io/categories/algorithm/"/>
    
      <category term="baekjoon" scheme="https://int31302.github.io/categories/algorithm/baekjoon/"/>
    
      <category term="silver" scheme="https://int31302.github.io/categories/algorithm/baekjoon/silver/"/>
    
    
      <category term="algorithm" scheme="https://int31302.github.io/tags/algorithm/"/>
    
      <category term="baeakjoon" scheme="https://int31302.github.io/tags/baeakjoon/"/>
    
      <category term="1654번" scheme="https://int31302.github.io/tags/1654%EB%B2%88/"/>
    
      <category term="이진탐색" scheme="https://int31302.github.io/tags/%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/"/>
    
      <category term="binary_search" scheme="https://int31302.github.io/tags/binary-search/"/>
    
  </entry>
  
</feed>
